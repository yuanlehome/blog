---
import { createHeadingSlugger } from '../utils/slugger';

interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
}

const slugger = createHeadingSlugger();
const headings = Astro.props.headings
  .filter((heading) => heading.depth <= 3)
  .map((heading) => ({
    ...heading,
    slug: slugger(heading.text),
    indentClass: heading.depth === 3 ? 'pl-4' : '',
  }));

const headerOffset = 96; // px, roughly matches the header height (py-6 + logo) to avoid overlap
---

<div class="w-full" data-toc-shell>
  <aside class="hidden lg:block h-full">
    <div
      class="flex h-full w-full flex-col gap-3 overflow-hidden rounded-xl border border-gray-200 bg-gray-50/80 p-4 shadow-md backdrop-blur-sm dark:border-gray-800 dark:bg-gray-800/50 lg:sticky lg:top-[calc(var(--toc-offset)+1rem)] lg:max-h-[calc(100vh-var(--toc-offset)-1.5rem)] lg:h-[calc(100vh-var(--toc-offset)-1.5rem)]"
      style={`--toc-offset: ${headerOffset}px`}
      data-toc-container
    >
      <div class="space-y-1">
        <p class="text-sm font-semibold text-gray-900 dark:text-gray-100">文章目录</p>
        <p class="text-xs text-gray-500 dark:text-gray-400">快速跳转到你关心的章节</p>
      </div>
      {
        headings.length === 0 ? (
          <p class="text-sm text-gray-500 dark:text-gray-400">本文暂无目录。</p>
        ) : (
          <nav aria-label="文章目录" class="flex-1 min-h-0 overflow-y-auto pr-1" data-toc-scroll>
            <ol class="space-y-2 text-sm">
              {headings.map((heading) => (
                <li>
                  <a
                    href={`#${heading.slug}`}
                    data-toc-link
                    data-target={heading.slug}
                    title={heading.text}
                    class={`group flex items-start gap-2 truncate text-gray-700 underline-offset-2 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 dark:text-gray-200 dark:focus-visible:ring-offset-gray-900 ${heading.indentClass}`}
                  >
                    <span class="mt-0.5 text-xs text-gray-400 transition-colors group-data-[active=true]:text-blue-600 dark:text-gray-500 dark:group-data-[active=true]:text-blue-400">
                      #
                    </span>
                    <span class="flex-1 truncate" data-title>
                      {heading.text}
                    </span>
                  </a>
                </li>
              ))}
            </ol>
          </nav>
        )
      }
    </div>
  </aside>
</div>

<script>
  const tocLinks = Array.from(document.querySelectorAll('[data-toc-link]')) as HTMLAnchorElement[];
  const tocContainer = document.querySelector('[data-toc-container]') as HTMLElement | null;
  const tocShell = document.querySelector('[data-toc-shell]') as HTMLElement | null;
  const headerOffsetPx =
    (tocContainer && getComputedStyle(tocContainer).getPropertyValue('--toc-offset')) || '96px';
  const headerOffset = parseFloat(headerOffsetPx) || 0;
  const desktopQuery = window.matchMedia('(min-width: 1024px)');

  const headings = tocLinks
    .map((link) => document.getElementById(link.dataset.target || ''))
    .filter((el): el is HTMLElement => Boolean(el));

  const applyScrollMargin = () => {
    headings.forEach((heading) => {
      heading.style.scrollMarginTop = `${headerOffset + 12}px`;
    });
  };

  const encodedHash = (id: string) => `#${encodeURIComponent(id)}`;
  const decodeHash = (hash: string) => decodeURIComponent(hash.replace(/^#/, ''));

  const setActive = (id: string | null) => {
    tocLinks.forEach((link) => {
      const isActive = link.dataset.target === id;
      link.dataset.active = isActive ? 'true' : 'false';
      link.setAttribute('aria-current', isActive ? 'true' : 'false');
    });
  };

  const scrollToHeading = (id: string, replace = false) => {
    const target = document.getElementById(id);
    if (!target) return;
    const top = window.scrollY + target.getBoundingClientRect().top - headerOffset - 12;
    if (replace) {
      history.replaceState(null, '', encodedHash(id));
    } else {
      history.pushState(null, '', encodedHash(id));
    }
    window.scrollTo({ top, behavior: 'smooth' });
    setActive(id);
  };

  tocLinks.forEach((link) =>
    link.addEventListener('click', (event) => {
      const targetId = link.dataset.target;
      if (!targetId) return;
      event.preventDefault();
      scrollToHeading(targetId);
    }),
  );

  const resetPositioning = () => {
    if (!tocContainer) return;
    tocContainer.dataset.fixed = 'false';
    tocContainer.style.position = '';
    tocContainer.style.left = '';
    tocContainer.style.width = '';
    tocContainer.style.height = '';
    tocContainer.style.maxHeight = '';
    tocContainer.style.top = '';
    if (tocShell) tocShell.style.minHeight = '';
  };

  const applyFixedFallback = () => {
    if (!tocContainer || !tocShell) return;
    const shellRect = tocShell.getBoundingClientRect();
    const maxHeight = `calc(100vh - ${headerOffsetPx} - 1.5rem)`;
    tocContainer.dataset.fixed = 'true';
    tocShell.style.minHeight = `${tocContainer.offsetHeight}px`;
    tocContainer.style.position = 'fixed';
    tocContainer.style.top = `calc(${headerOffsetPx} + 1rem)`;
    tocContainer.style.left = `${shellRect.left}px`;
    tocContainer.style.width = `${shellRect.width}px`;
    tocContainer.style.height = maxHeight;
    tocContainer.style.maxHeight = maxHeight;
  };

  const verifySticky = () => {
    if (!tocContainer || tocContainer.dataset.fixed === 'true' || !desktopQuery.matches) return;
    const stickyTop = parseFloat(getComputedStyle(tocContainer).top || '0');
    const threshold = tocContainer.offsetTop - stickyTop;
    if (Number.isNaN(stickyTop) || window.scrollY < threshold) return;
    const currentTop = tocContainer.getBoundingClientRect().top;
    if (Math.abs(currentTop - stickyTop) > 2) {
      applyFixedFallback();
    }
  };

  const handleResize = () => {
    if (!desktopQuery.matches) {
      resetPositioning();
      return;
    }
    if (tocContainer?.dataset.fixed === 'true') {
      applyFixedFallback();
    }
  };

  if (headings.length > 0) {
    applyScrollMargin();
    setActive(headings[0].id);
    const rootMarginTop =
      (tocContainer && getComputedStyle(tocContainer).getPropertyValue('--toc-offset')) || '96px';
    const observer = new IntersectionObserver(
      (entries) => {
        const visible = entries
          .filter((entry) => entry.isIntersecting)
          .sort(
            (a, b) => a.target.getBoundingClientRect().top - b.target.getBoundingClientRect().top,
          );

        if (visible[0]) {
          setActive(visible[0].target.id);
          return;
        }

        const above = entries
          .filter((entry) => entry.boundingClientRect.top < 0)
          .sort(
            (a, b) => b.target.getBoundingClientRect().top - a.target.getBoundingClientRect().top,
          );
        if (above[0]) setActive(above[0].target.id);
      },
      {
        rootMargin: `-${rootMarginTop.trim()} 0% -55% 0%`,
        threshold: [0, 0.25, 0.5, 1],
      },
    );

    headings.forEach((heading) => observer.observe(heading));

    const hash = decodeHash(location.hash || '');
    if (hash) {
      requestAnimationFrame(() => scrollToHeading(hash, true));
    }

    window.addEventListener('hashchange', () => {
      const id = decodeHash(location.hash || '');
      if (id) scrollToHeading(id, true);
    });
  }

  resetPositioning();
  if (desktopQuery.matches) verifySticky();
  desktopQuery.addEventListener('change', () => {
    resetPositioning();
    requestAnimationFrame(() => {
      if (desktopQuery.matches) verifySticky();
    });
  });
  window.addEventListener('scroll', verifySticky, { passive: true });
  window.addEventListener('resize', handleResize);
  window.addEventListener(
    'load',
    () => {
      verifySticky();
      applyScrollMargin();
    },
    { once: true },
  );
</script>
