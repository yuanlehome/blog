---
import TocTree from './TocTree.astro';
import { buildTocForest, type Heading } from '../lib/content/tocTree';

interface Props {
  headings: Heading[];
}

// Build tree structure supporting multiple H1s
const tocForest = buildTocForest(Astro.props.headings);
if (tocForest.length === 0) {
  return null;
}
---

<div class="w-full" data-toc-shell>
  <aside class="hidden lg:block h-full">
    <div
      class="flex h-full w-full flex-col gap-3 overflow-hidden rounded-xl border border-cyan-500/20 bg-zinc-900/60 p-4 shadow-[0_8px_32px_rgba(0,0,0,0.4),0_0_0_1px_rgba(34,211,238,0.2)] backdrop-blur-md dark:border-cyan-400/30 dark:bg-zinc-950/70 dark:shadow-[0_8px_32px_rgba(0,0,0,0.6),0_0_12px_rgba(34,211,238,0.15)] lg:sticky lg:top-[var(--site-header-height)] lg:max-h-[calc(100vh-var(--site-header-height)-16px)] lg:h-[calc(100vh-var(--site-header-height)-16px)]"
      data-toc-container
    >
      <div class="space-y-1">
        <p class="text-sm font-semibold text-cyan-300 dark:text-cyan-200">文章目录</p>
        <p class="text-xs text-zinc-400 dark:text-zinc-500">快速跳转到你关心的章节</p>
      </div>
      <nav aria-label="文章目录" class="flex-1 min-h-0 overflow-y-auto pr-1" data-toc-scroll>
        <ol class="space-y-3 text-sm">
          <TocTree nodes={tocForest} />
        </ol>
      </nav>
    </div>
  </aside>
</div>

<script>
  const tocLinks = Array.from(document.querySelectorAll('[data-toc-link]')) as HTMLAnchorElement[];
  const tocContainer = document.querySelector('[data-toc-container]') as HTMLElement | null;
  const tocShell = document.querySelector('[data-toc-shell]') as HTMLElement | null;

  // Get header offset from CSS variable
  const getHeaderOffset = (): number => {
    const headerHeightStr = getComputedStyle(document.documentElement).getPropertyValue(
      '--site-header-height',
    );
    return parseFloat(headerHeightStr) || 0;
  };

  const desktopQuery = window.matchMedia('(min-width: 1024px)');

  const headings = tocLinks
    .map((link) => document.getElementById(link.dataset.target || ''))
    .filter((el): el is HTMLElement => Boolean(el));

  const applyScrollMargin = () => {
    const headerOffset = getHeaderOffset();
    headings.forEach((heading) => {
      heading.style.scrollMarginTop = `${headerOffset + 12}px`;
    });
  };

  const encodedHash = (id: string) => `#${encodeURIComponent(id)}`;
  const decodeHash = (hash: string) => decodeURIComponent(hash.replace(/^#/, ''));

  const setActive = (id: string | null) => {
    tocLinks.forEach((link) => {
      const isActive = link.dataset.target === id;
      link.dataset.active = isActive ? 'true' : 'false';
      link.setAttribute('aria-current', isActive ? 'true' : 'false');
    });
  };

  const scrollToHeading = (id: string, replace = false) => {
    const target = document.getElementById(id);
    if (!target) return;
    const headerOffset = getHeaderOffset();
    const top = window.scrollY + target.getBoundingClientRect().top - headerOffset - 12;
    if (replace) {
      history.replaceState(null, '', encodedHash(id));
    } else {
      history.pushState(null, '', encodedHash(id));
    }
    window.scrollTo({ top, behavior: 'smooth' });
    setActive(id);
  };

  tocLinks.forEach((link) =>
    link.addEventListener('click', (event) => {
      const targetId = link.dataset.target;
      if (!targetId) return;
      event.preventDefault();
      scrollToHeading(targetId);
    }),
  );

  const resetPositioning = () => {
    if (!tocContainer) return;
    tocContainer.dataset.fixed = 'false';
    tocContainer.style.position = '';
    tocContainer.style.left = '';
    tocContainer.style.width = '';
    tocContainer.style.height = '';
    tocContainer.style.maxHeight = '';
    tocContainer.style.top = '';
    if (tocShell) tocShell.style.minHeight = '';
  };

  const applyFixedFallback = () => {
    if (!tocContainer || !tocShell) return;
    const shellRect = tocShell.getBoundingClientRect();
    const headerOffset = getHeaderOffset();
    const maxHeight = `calc(100vh - ${headerOffset}px - 16px)`;
    tocContainer.dataset.fixed = 'true';
    tocShell.style.minHeight = `${tocContainer.offsetHeight}px`;
    tocContainer.style.position = 'fixed';
    tocContainer.style.top = `${headerOffset}px`;
    tocContainer.style.left = `${shellRect.left}px`;
    tocContainer.style.width = `${shellRect.width}px`;
    tocContainer.style.height = maxHeight;
    tocContainer.style.maxHeight = maxHeight;
  };

  const verifySticky = () => {
    if (!tocContainer || tocContainer.dataset.fixed === 'true' || !desktopQuery.matches) return;
    const stickyTop = parseFloat(getComputedStyle(tocContainer).top || '0');
    const threshold = tocContainer.offsetTop - stickyTop;
    if (Number.isNaN(stickyTop) || window.scrollY < threshold) return;
    const currentTop = tocContainer.getBoundingClientRect().top;
    if (Math.abs(currentTop - stickyTop) > 2) {
      applyFixedFallback();
    }
  };

  const handleResize = () => {
    if (!desktopQuery.matches) {
      resetPositioning();
      return;
    }
    if (tocContainer?.dataset.fixed === 'true') {
      applyFixedFallback();
    }
  };

  if (headings.length > 0) {
    applyScrollMargin();

    const observer = new IntersectionObserver(
      (entries) => {
        const visible = entries
          .filter((entry) => entry.isIntersecting)
          .sort(
            (a, b) => a.target.getBoundingClientRect().top - b.target.getBoundingClientRect().top,
          );

        if (visible[0]) {
          setActive(visible[0].target.id);
          return;
        }

        const above = entries
          .filter((entry) => entry.boundingClientRect.top < 0)
          .sort(
            (a, b) => b.target.getBoundingClientRect().top - a.target.getBoundingClientRect().top,
          );
        if (above[0]) setActive(above[0].target.id);
      },
      {
        rootMargin: `-${getHeaderOffset()}px 0% -55% 0%`,
        threshold: [0, 0.25, 0.5, 1],
      },
    );

    headings.forEach((heading) => observer.observe(heading));

    const hash = decodeHash(location.hash || '');
    if (hash) {
      requestAnimationFrame(() => scrollToHeading(hash, true));
    }

    window.addEventListener('hashchange', () => {
      const id = decodeHash(location.hash || '');
      if (id) scrollToHeading(id, true);
    });
  }

  resetPositioning();
  if (desktopQuery.matches) verifySticky();
  desktopQuery.addEventListener('change', () => {
    resetPositioning();
    requestAnimationFrame(() => {
      if (desktopQuery.matches) verifySticky();
    });
  });
  window.addEventListener('scroll', verifySticky, { passive: true });
  window.addEventListener('resize', handleResize);
  window.addEventListener(
    'load',
    () => {
      verifySticky();
      applyScrollMargin();
    },
    { once: true },
  );

  // Listen for header height changes via custom event (more efficient than MutationObserver)
  window.addEventListener('headerheightchange', () => {
    applyScrollMargin();
  });
</script>
