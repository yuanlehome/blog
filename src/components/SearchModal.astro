---
import { MiniSearchLite } from '../utils/mini-search-lite';
const BASE = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : import.meta.env.BASE_URL + '/';
---

<div
  id="search-modal"
  class="hidden fixed inset-0 z-50 items-start justify-center bg-black/50 backdrop-blur-sm p-4"
  role="dialog"
  aria-modal="true"
  aria-label="Search"
>
  <div class="relative mt-10 w-full max-w-3xl rounded-2xl bg-white shadow-2xl ring-1 ring-black/10 dark:bg-gray-900 dark:ring-white/10">
    <div class="flex items-center justify-between border-b border-gray-200 px-4 py-3 dark:border-gray-800">
      <div class="text-sm text-gray-600 dark:text-gray-300">Press <span class="font-semibold">Ctrl/Cmd + K</span> to search</div>
      <button
        id="close-search"
        class="rounded-md border border-transparent px-2 py-1 text-sm text-gray-500 transition hover:border-gray-300 hover:bg-gray-100 dark:hover:border-gray-700 dark:hover:bg-gray-800"
      >
        Esc
      </button>
    </div>
    <div class="p-4">
      <div class="relative mb-3">
        <span class="pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">üîç</span>
        <input
          id="search-input"
          type="search"
          placeholder="Type to search posts..."
          class="w-full rounded-lg border border-gray-200 bg-white/70 pl-10 pr-28 py-3 text-base shadow-sm transition focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-200 dark:border-gray-700 dark:bg-gray-800/80 dark:focus:border-blue-400 dark:focus:ring-blue-800"
        />
        <div class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 text-xs text-gray-500 dark:text-gray-400">‚åò / Ctrl + K</div>
      </div>
      <div id="search-state" class="mb-3 text-sm text-gray-500 dark:text-gray-400">Start typing to search across all posts.</div>
      <div id="search-results" class="max-h-[60vh] overflow-y-auto divide-y divide-gray-100 dark:divide-gray-800"></div>
    </div>
  </div>
</div>

<style>
  mark {
    background-color: #fef08a;
    color: inherit;
    padding: 0 2px;
  }
</style>

<script type="module">
  const modal = document.getElementById('search-modal');
  const openers = document.querySelectorAll('[data-search-trigger]');
  const closeBtn = document.getElementById('close-search');
  const searchInput = document.getElementById('search-input');
  const resultsContainer = document.getElementById('search-results');
  const stateEl = document.getElementById('search-state');

  let searchInstance = null;
  let metadata = new Map();
  let isLoading = false;

  const toggleBodyScroll = (lock) => {
    document.body.classList.toggle('overflow-hidden', lock);
  };

  const renderState = (message) => {
    if (stateEl) stateEl.textContent = message;
  };

  const renderEmpty = () => {
    if (!resultsContainer) return;
    resultsContainer.innerHTML = '<p class="py-6 text-center text-gray-500 dark:text-gray-400">No matches found.</p>';
  };

  const buildSnippet = (text, terms) => {
    const clean = (text ?? '').replace(/\s+/g, ' ').trim();
    if (!clean) return '';

    const lower = clean.toLowerCase();
    let startIndex = 0;
    let firstHit = Infinity;

    for (const term of terms) {
      const idx = lower.indexOf(String(term).toLowerCase());
      if (idx !== -1 && idx < firstHit) {
        firstHit = idx;
      }
    }

    if (firstHit !== Infinity) {
      startIndex = Math.max(0, firstHit - 30);
    }

    const snippet = clean.slice(startIndex, startIndex + 200);
    const prefix = startIndex > 0 ? '‚Ä¶' : '';
    const suffix = startIndex + 200 < clean.length ? '‚Ä¶' : '';
    return prefix + MiniSearchLite.highlight(snippet, terms) + suffix;
  };

  const renderResults = (results) => {
    if (!resultsContainer) return;
    if (!results.length) {
      renderEmpty();
      renderState('No matches found');
      return;
    }

    const fragment = document.createDocumentFragment();
    results.slice(0, 30).forEach((result) => {
      const meta = metadata.get(result.id);
      if (!meta) return;
      const terms = result.terms;
      const snippet = buildSnippet(meta.paragraph, terms);
      const headingText = meta.heading || meta.title;
      const item = document.createElement('a');
      item.href = `${BASE}${meta.slug}/#${result.id.split('#')[1] ?? ''}`;
      item.className = 'block px-3 py-4 transition hover:bg-gray-50 dark:hover:bg-gray-800';
      item.innerHTML = `
        <div class="mb-1 text-sm text-gray-500 dark:text-gray-400">${headingText ? MiniSearchLite.highlight(headingText, terms) : ''}</div>
        <div class="mb-1 text-lg font-semibold text-gray-900 dark:text-gray-100">${MiniSearchLite.highlight(meta.title, terms)}</div>
        <p class="text-sm text-gray-600 dark:text-gray-300 leading-relaxed">${snippet}</p>
        <div class="mt-2 flex flex-wrap items-center gap-2 text-xs text-gray-500 dark:text-gray-400">
          ${meta.date ? `<span>üìÖ ${meta.date}</span>` : ''}
          ${meta.tags?.length ? meta.tags.map((tag) => `<span class="rounded bg-gray-100 px-2 py-0.5 dark:bg-gray-800">#${tag}</span>`).join('') : ''}
        </div>
      `;
      fragment.appendChild(item);
    });

    resultsContainer.innerHTML = '';
    resultsContainer.appendChild(fragment);
    renderState(`${results.length} result${results.length > 1 ? 's' : ''} found`);
  };

  const ensureIndexLoaded = async () => {
    if (searchInstance || isLoading) return searchInstance;
    isLoading = true;
    renderState('Loading search index...');
    try {
      const [indexJson, metaJson] = await Promise.all([
        fetch(`${BASE}search/index.json`).then((res) => res.json()),
        fetch(`${BASE}search/metadata.json`).then((res) => res.json()),
      ]);
      searchInstance = MiniSearchLite.loadJSON(indexJson);
      metadata = new Map(metaJson.map((entry) => [entry.id, entry]));
      renderState('Index ready. Start typing to search across all posts.');
      return searchInstance;
    } catch (error) {
      console.error('Failed to load search index', error);
      renderState('Unable to load search index. Please try again.');
      return null;
    } finally {
      isLoading = false;
    }
  };

  const openModal = async () => {
    if (!modal) return;
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    toggleBodyScroll(true);
    await ensureIndexLoaded();
    requestAnimationFrame(() => searchInput?.focus());
  };

  const closeModal = () => {
    if (!modal) return;
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    toggleBodyScroll(false);
  };

  const handleSearch = (event) => {
    const value = event.target.value || '';
    if (!searchInstance) {
      renderState('Search index is still loading...');
      return;
    }
    if (!value.trim()) {
      renderState('Type to search across all posts.');
      resultsContainer.innerHTML = '';
      return;
    }

    const results = searchInstance.search(value.trim());
    renderResults(results);
  };

  openers.forEach((btn) => btn.addEventListener('click', openModal));
  closeBtn?.addEventListener('click', closeModal);
  modal?.addEventListener('click', (event) => {
    if (event.target === modal) {
      closeModal();
    }
  });

  searchInput?.addEventListener('input', handleSearch);

  window.addEventListener('keydown', (event) => {
    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'k') {
      event.preventDefault();
      openModal();
    }
    if (event.key === 'Escape') {
      closeModal();
    }
  });
</script>
