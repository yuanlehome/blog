---
import { normalizeBase } from '../lib/slug';
import { getNavConfig, getLayoutConfig } from '../config/loaders';
import { alignToJustifyClass, alignToItemsClass } from '../lib/ui/alignment';

const BASE = normalizeBase(import.meta.env.BASE_URL);
const navConfig = getNavConfig();
const layoutConfig = getLayoutConfig();

// Get alignment classes from config
const headerAlign = layoutConfig.alignment.headerAlign;
const justifyClass = alignToJustifyClass(headerAlign);
const itemsClass = alignToItemsClass(headerAlign);

// Get current path for active link highlighting
const currentPath = Astro.url.pathname;

// Helper to construct menu item URLs
function getMenuItemUrl(item: { isExternal: boolean; href: string }): string {
  if (item.isExternal) {
    return item.href;
  }
  // Remove leading slash from href and append to BASE
  const path = item.href.startsWith('/') ? item.href.slice(1) : item.href;
  return `${BASE}${path}`;
}

// Helper to check if a menu item is active
function isMenuItemActive(item: { href: string; isExternal: boolean }): boolean {
  if (item.isExternal) return false;

  const itemPath = getMenuItemUrl(item);
  const normalizedCurrent = currentPath.endsWith('/') ? currentPath : `${currentPath}/`;
  const normalizedItem = itemPath.endsWith('/') ? itemPath : `${itemPath}/`;

  // Exact match or path starts with menu item (for tags/[slug])
  return (
    normalizedCurrent === normalizedItem ||
    (item.href.startsWith('/tags') && normalizedCurrent.startsWith(normalizedItem))
  );
}
---

<header class="site-header header-variant-frosted" data-header>
  <div
    class={`container mx-auto px-5 py-3 sm:py-4 flex ${justifyClass === 'justify-center' ? 'justify-center' : 'justify-between'} ${itemsClass} max-w-5xl`}
  >
    <a
      href={BASE}
      class="text-xl font-bold hover:text-sky-600 dark:hover:text-sky-400 flex items-center gap-2"
    >
      {
        navConfig.header.brandLogo && (
          <img
            src={`${BASE}${navConfig.header.brandLogo.startsWith('/') ? navConfig.header.brandLogo.slice(1) : navConfig.header.brandLogo}`}
            alt={navConfig.header.brandText}
            width="32"
            height="32"
            class="h-8 w-8 rounded"
          />
        )
      }
      {navConfig.header.brandText}
    </a>
    <nav class={`flex ${itemsClass} gap-3 items-center`}>
      {
        navConfig.header.menuItems.map((item) => {
          const isActive = isMenuItemActive(item);
          return (
            <a
              href={getMenuItemUrl(item)}
              class={`hover:underline inline-flex items-center ${isActive ? 'text-sky-600 dark:text-sky-400 font-semibold' : ''}`}
              target={item.openInNewTab ? '_blank' : undefined}
              rel={item.openInNewTab ? 'noopener noreferrer' : undefined}
              aria-current={isActive ? 'page' : undefined}
            >
              {item.label}
            </a>
          );
        })
      }
      {
        navConfig.theme.enableToggle && (
          <button
            id="theme-toggle"
            class="inline-flex items-center gap-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-800 px-1"
            aria-label="Toggle theme"
          >
            {navConfig.theme.icons.default}
            {navConfig.theme.icons.light}
          </button>
        )
      }
    </nav>
  </div>
</header>

<script>
  const storageKey = 'theme';
  const order: Array<'light' | 'dark'> = ['light', 'dark'];

  const getPreference = (): 'light' | 'dark' => {
    try {
      const value = localStorage.getItem(storageKey);
      if (value === 'light' || value === 'dark') return value;
    } catch (error) {
      console.warn('Unable to read theme preference:', error);
    }
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  };

  const getResolvedTheme = (): 'light' | 'dark' =>
    document.documentElement.classList.contains('dark') ? 'dark' : 'light';

  const iconFor = (preference: 'light' | 'dark') => (preference === 'dark' ? 'ðŸŒ™' : 'â˜€ï¸');

  const labelFor = (preference: 'light' | 'dark') => (preference === 'dark' ? 'Dark' : 'Light');

  const render = (preference: 'light' | 'dark', resolvedOverride?: 'light' | 'dark') => {
    const button = document.getElementById('theme-toggle');
    if (!button) return;
    const resolved: 'light' | 'dark' = resolvedOverride ?? getResolvedTheme();
    const icon = iconFor(resolved);
    const label = labelFor(resolved);
    (button as HTMLElement).dataset.theme = preference;
    // Clear button and create elements to wrap emoji for baseline alignment
    button.textContent = '';
    const iconSpan = document.createElement('span');
    iconSpan.className = 'inline-flex items-center justify-center';
    iconSpan.style.lineHeight = '1';
    iconSpan.textContent = icon;
    button.appendChild(iconSpan);
    button.appendChild(document.createTextNode(' ' + label));
    button.setAttribute('aria-label', `Toggle theme (current: ${label})`);
  };

  declare global {
    interface Window {
      __setTheme?: (preference: 'light' | 'dark') => void;
    }
  }

  const applyPreference = (preference: 'light' | 'dark') => {
    if (typeof window.__setTheme === 'function') {
      window.__setTheme?.(preference);
      return;
    }

    const resolved: 'light' | 'dark' = preference === 'dark' ? 'dark' : 'light';
    document.documentElement.classList.toggle('dark', resolved === 'dark');
    try {
      localStorage.setItem(storageKey, preference);
    } catch (error) {
      console.warn('Unable to persist theme preference:', error);
    }
    window.dispatchEvent(
      new CustomEvent('themechange', { detail: { theme: preference, resolved } }),
    );
  };

  const handleToggleClick = () => {
    const current = getPreference();
    const next = order[(order.indexOf(current) + 1) % order.length];
    applyPreference(next);
    render(next);
  };

  const header = document.querySelector<HTMLElement>('[data-header]');
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  const updateHeaderState = () => {
    if (!header) return;
    const isScrolled = window.scrollY > 6;
    header.classList.toggle('is-scrolled', isScrolled);
  };

  document.getElementById('theme-toggle')?.addEventListener('click', handleToggleClick);
  render(getPreference());

  window.addEventListener('themechange', (event: Event) => {
    const detail = (event as CustomEvent<{ theme?: 'light' | 'dark'; resolved?: 'light' | 'dark' }>)
      .detail;
    const theme: 'light' | 'dark' = detail?.theme ?? getPreference();
    const resolved: 'light' | 'dark' | undefined = detail?.resolved;
    render(theme, resolved);
  });

  updateHeaderState();
  const scrollHandler = () => updateHeaderState();
  window.addEventListener('scroll', scrollHandler, { passive: true });

  if (prefersReducedMotion) {
    header?.classList.add('reduce-motion');
  }
</script>
