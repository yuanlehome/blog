---
import { normalizeBase } from '../lib/slug';
import { getNavConfig, getLayoutConfig } from '../config/loaders';
import { alignToJustifyClass, alignToItemsClass } from '../lib/ui/alignment';

const BASE = normalizeBase(import.meta.env.BASE_URL);
const navConfig = getNavConfig();
const layoutConfig = getLayoutConfig();

// Get alignment classes from config
const headerAlign = layoutConfig.alignment.headerAlign;
const justifyClass = alignToJustifyClass(headerAlign);
const itemsClass = alignToItemsClass(headerAlign);

// Helper to construct menu item URLs
function getMenuItemUrl(item: { isExternal: boolean; href: string }): string {
  if (item.isExternal) {
    return item.href;
  }
  // Remove leading slash from href and append to BASE
  const path = item.href.startsWith('/') ? item.href.slice(1) : item.href;
  return `${BASE}${path}`;
}
---

<header class="site-header header-variant-frosted" data-header>
  <div
    class={`container mx-auto px-5 py-3 sm:py-4 flex ${justifyClass === 'justify-center' ? 'justify-center' : 'justify-between'} ${itemsClass} max-w-5xl`}
  >
    <a href={BASE} class="text-xl font-bold hover:text-blue-600 dark:hover:text-blue-400"
      >{navConfig.header.brandText}</a
    >
    <nav class={`flex ${itemsClass} gap-3 items-center`}>
      {
        navConfig.header.menuItems.map((item) => (
          <a
            href={getMenuItemUrl(item)}
            class="hover:underline inline-flex items-center"
            target={item.openInNewTab ? '_blank' : undefined}
            rel={item.openInNewTab ? 'noopener noreferrer' : undefined}
          >
            {item.label}
          </a>
        ))
      }
      {
        navConfig.theme.enableToggle && (
          <button
            id="theme-toggle"
            class="inline-flex items-center gap-1 rounded hover:bg-gray-200 dark:hover:bg-gray-800 px-1"
            aria-label="Toggle theme"
          >
            {navConfig.theme.icons.default}
            {navConfig.theme.icons.light}
          </button>
        )
      }
    </nav>
  </div>
</header>

<script>
  const storageKey = 'theme';
  const order: Array<'light' | 'dark'> = ['light', 'dark'];

  const getPreference = (): 'light' | 'dark' => {
    try {
      const value = localStorage.getItem(storageKey);
      if (value === 'light' || value === 'dark') return value;
    } catch (error) {
      console.warn('Unable to read theme preference:', error);
    }
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  };

  const getResolvedTheme = (): 'light' | 'dark' =>
    document.documentElement.classList.contains('dark') ? 'dark' : 'light';

  const iconFor = (preference: 'light' | 'dark') => (preference === 'dark' ? 'ðŸŒ™' : 'â˜€ï¸');

  const labelFor = (preference: 'light' | 'dark') => (preference === 'dark' ? 'Dark' : 'Light');

  const render = (preference: 'light' | 'dark', resolvedOverride?: 'light' | 'dark') => {
    const button = document.getElementById('theme-toggle');
    if (!button) return;
    const resolved: 'light' | 'dark' = resolvedOverride ?? getResolvedTheme();
    const icon = iconFor(resolved);
    const label = labelFor(resolved);
    (button as HTMLElement).dataset.theme = preference;
    // Wrap emoji in a span to fix baseline alignment
    button.innerHTML = `<span class="inline-flex items-center justify-center" style="line-height: 1;">${icon}</span> ${label}`;
    button.setAttribute('aria-label', `Toggle theme (current: ${label})`);
  };

  declare global {
    interface Window {
      __setTheme?: (preference: 'light' | 'dark') => void;
    }
  }

  const applyPreference = (preference: 'light' | 'dark') => {
    if (typeof window.__setTheme === 'function') {
      window.__setTheme?.(preference);
      return;
    }

    const resolved: 'light' | 'dark' = preference === 'dark' ? 'dark' : 'light';
    document.documentElement.classList.toggle('dark', resolved === 'dark');
    try {
      localStorage.setItem(storageKey, preference);
    } catch (error) {
      console.warn('Unable to persist theme preference:', error);
    }
    window.dispatchEvent(
      new CustomEvent('themechange', { detail: { theme: preference, resolved } }),
    );
  };

  const handleToggleClick = () => {
    const current = getPreference();
    const next = order[(order.indexOf(current) + 1) % order.length];
    applyPreference(next);
    render(next);
  };

  const header = document.querySelector<HTMLElement>('[data-header]');
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  const updateHeaderState = () => {
    if (!header) return;
    const isScrolled = window.scrollY > 6;
    header.classList.toggle('is-scrolled', isScrolled);
  };

  document.getElementById('theme-toggle')?.addEventListener('click', handleToggleClick);
  render(getPreference());

  window.addEventListener('themechange', (event: Event) => {
    const detail = (event as CustomEvent<{ theme?: 'light' | 'dark'; resolved?: 'light' | 'dark' }>)
      .detail;
    const theme: 'light' | 'dark' = detail?.theme ?? getPreference();
    const resolved: 'light' | 'dark' | undefined = detail?.resolved;
    render(theme, resolved);
  });

  updateHeaderState();
  const scrollHandler = () => updateHeaderState();
  window.addEventListener('scroll', scrollHandler, { passive: true });

  if (prefersReducedMotion) {
    header?.classList.add('reduce-motion');
  }
</script>
