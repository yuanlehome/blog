---
import { normalizeBase } from '../lib/slug';
import { getNavConfig, getLayoutConfig } from '../config/loaders';
import { alignToJustifyClass, alignToItemsClass } from '../lib/ui/alignment';

const BASE = normalizeBase(import.meta.env.BASE_URL);
const navConfig = getNavConfig();
const layoutConfig = getLayoutConfig();

// Get alignment classes from config
const headerAlign = layoutConfig.alignment.headerAlign;
const justifyClass = alignToJustifyClass(headerAlign);
const itemsClass = alignToItemsClass(headerAlign);

// Get current path for active link highlighting
const currentPath = Astro.url.pathname;

// Helper to construct menu item URLs
function getMenuItemUrl(item: { isExternal: boolean; href: string }): string {
  if (item.isExternal) {
    return item.href;
  }
  // Remove leading slash from href and append to BASE
  const path = item.href.startsWith('/') ? item.href.slice(1) : item.href;
  return `${BASE}${path}`;
}

// Helper to check if a menu item is active
function isMenuItemActive(item: { href: string; isExternal: boolean }): boolean {
  if (item.isExternal) return false;

  const itemPath = getMenuItemUrl(item);
  const normalizedCurrent = currentPath.endsWith('/') ? currentPath : `${currentPath}/`;
  const normalizedItem = itemPath.endsWith('/') ? itemPath : `${itemPath}/`;

  // Exact match or path starts with menu item (for tags/[slug])
  return (
    normalizedCurrent === normalizedItem ||
    (item.href.startsWith('/tags') && normalizedCurrent.startsWith(normalizedItem))
  );
}
---

<header class="site-header header-variant-frosted" data-header data-site-header>
  <div
    class={`container mx-auto px-5 py-3 sm:py-4 flex ${justifyClass === 'justify-center' ? 'justify-center' : 'justify-between'} ${itemsClass} max-w-5xl`}
  >
    <a
      href={BASE}
      class="text-xl font-bold hover:text-sky-600 dark:hover:text-sky-400 flex items-center gap-2"
    >
      {
        navConfig.header.brandLogo && (
          <img
            src={`${BASE}${navConfig.header.brandLogo.startsWith('/') ? navConfig.header.brandLogo.slice(1) : navConfig.header.brandLogo}`}
            alt={navConfig.header.brandText}
            width="32"
            height="32"
            class="h-8 w-8 rounded"
          />
        )
      }
      <span class="hidden sm:inline">{navConfig.header.brandText}</span>
    </a>
    <nav class={`flex ${itemsClass} gap-3 items-center`}>
      {
        navConfig.header.menuItems.map((item) => {
          const isActive = isMenuItemActive(item);
          return (
            <a
              href={getMenuItemUrl(item)}
              class={`hover:underline inline-flex items-center ${isActive ? 'text-sky-600 dark:text-sky-400 font-semibold' : ''}`}
              target={item.openInNewTab ? '_blank' : undefined}
              rel={item.openInNewTab ? 'noopener noreferrer' : undefined}
              aria-current={isActive ? 'page' : undefined}
            >
              {item.label}
            </a>
          );
        })
      }
      {
        navConfig.theme.enableToggle && (
          <button
            id="theme-toggle"
            class="inline-flex items-center gap-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-800 px-1"
            aria-label="Toggle theme"
          >
            {navConfig.theme.icons.default}
            {navConfig.theme.icons.light}
          </button>
        )
      }
    </nav>
  </div>
</header>

<script>
  const storageKey = 'theme';
  const order: Array<'light' | 'dark'> = ['light', 'dark'];
  const toggleLockMs = 500;
  const animationSafetyBufferMs = 50;

  const getPreference = (): 'light' | 'dark' => {
    try {
      const value = localStorage.getItem(storageKey);
      if (value === 'light' || value === 'dark') return value;
    } catch (error) {
      console.warn('Unable to read theme preference:', error);
    }
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  };

  const getResolvedTheme = (): 'light' | 'dark' =>
    document.documentElement.classList.contains('dark') ? 'dark' : 'light';

  const iconFor = (preference: 'light' | 'dark') => (preference === 'dark' ? 'ðŸŒ™' : 'â˜€ï¸');

  const labelFor = (preference: 'light' | 'dark') => (preference === 'dark' ? 'Dark' : 'Light');

  const render = (preference: 'light' | 'dark', resolvedOverride?: 'light' | 'dark') => {
    const button = document.getElementById('theme-toggle');
    if (!button) return;
    const resolved: 'light' | 'dark' = resolvedOverride ?? getResolvedTheme();
    const icon = iconFor(resolved);
    const label = labelFor(resolved);
    (button as HTMLElement).dataset.theme = preference;
    // Clear button and create elements to wrap emoji for baseline alignment
    button.textContent = '';
    const iconSpan = document.createElement('span');
    iconSpan.className = 'inline-flex items-center justify-center';
    iconSpan.style.lineHeight = '1';
    iconSpan.textContent = icon;
    button.appendChild(iconSpan);
    button.appendChild(document.createTextNode(' ' + label));
    button.setAttribute('aria-label', `Toggle theme (current: ${label})`);
  };

  declare global {
    interface Window {
      __setTheme?: (preference: 'light' | 'dark') => void;
    }
  }

  type ThemeOrigin = { x: number; y: number; r: number };

  type DocumentWithViewTransition = Document & {
    startViewTransition?: (updateCallback: () => void) => { finished: Promise<void> };
  };

  const applyPreference = (preference: 'light' | 'dark') => {
    if (typeof window.__setTheme === 'function') {
      window.__setTheme?.(preference);
      return;
    }

    const resolved: 'light' | 'dark' = preference === 'dark' ? 'dark' : 'light';
    document.documentElement.classList.toggle('dark', resolved === 'dark');
    try {
      localStorage.setItem(storageKey, preference);
    } catch (error) {
      console.warn('Unable to persist theme preference:', error);
    }
    window.dispatchEvent(
      new CustomEvent('themechange', { detail: { theme: preference, resolved } }),
    );
  };

  const getThemeOrigin = (event: Event, button: HTMLElement): ThemeOrigin => {
    const rect = button.getBoundingClientRect();
    const isMouseEvent = event instanceof MouseEvent;
    const hasPointerCoordinates =
      isMouseEvent && event.detail > 0 && (event.clientX !== 0 || event.clientY !== 0);
    const x = hasPointerCoordinates && isMouseEvent ? event.clientX : rect.left + rect.width / 2;
    const y = hasPointerCoordinates && isMouseEvent ? event.clientY : rect.top + rect.height / 2;
    const r = Math.max(
      Math.hypot(x, y),
      Math.hypot(window.innerWidth - x, y),
      Math.hypot(x, window.innerHeight - y),
      Math.hypot(window.innerWidth - x, window.innerHeight - y),
    );

    return { x, y, r };
  };

  const setThemeTransitionVariables = ({ x, y, r }: ThemeOrigin) => {
    const root = document.documentElement;
    root.style.setProperty('--theme-toggle-x', `${x}px`);
    root.style.setProperty('--theme-toggle-y', `${y}px`);
    root.style.setProperty('--theme-toggle-r', `${r}px`);
  };

  const animateThemeToggle = async (
    preference: 'light' | 'dark',
    origin: ThemeOrigin,
    reducedMotion: boolean,
  ) => {
    if (reducedMotion) {
      applyPreference(preference);
      render(preference);
      return;
    }

    setThemeTransitionVariables(origin);
    document.documentElement.classList.add('theme-toggle-transitioning');
    const doc = document as DocumentWithViewTransition;

    try {
      if (typeof doc.startViewTransition === 'function') {
        const transition = doc.startViewTransition(() => {
          applyPreference(preference);
          render(preference);
        });
        await transition.finished.catch((error) => {
          console.warn('Theme view transition failed:', error);
        });
        return;
      }

      const overlay = document.createElement('div');
      overlay.className = 'theme-toggle-overlay';
      if (preference === 'dark') overlay.classList.add('dark');
      document.body.appendChild(overlay);
      try {
        overlay.getBoundingClientRect();
        overlay.classList.add('is-animating');

        await new Promise<void>((resolve) => {
          let done = false;
          const finish = () => {
            if (done) return;
            done = true;
            resolve();
          };
          overlay.addEventListener('animationend', finish, { once: true });
          overlay.addEventListener('animationcancel', finish, { once: true });
          window.setTimeout(finish, toggleLockMs + animationSafetyBufferMs);
        });

        applyPreference(preference);
        render(preference);
      } finally {
        overlay.remove();
      }
    } finally {
      document.documentElement.classList.remove('theme-toggle-transitioning');
    }
  };

  let isAnimatingThemeToggle = false;

  const handleToggleClick = async (event: Event) => {
    if (isAnimatingThemeToggle) return;
    const button = event.currentTarget instanceof HTMLElement ? event.currentTarget : null;
    if (!button) return;

    isAnimatingThemeToggle = true;
    button.setAttribute('disabled', 'true');

    const current = getPreference();
    const next = order[(order.indexOf(current) + 1) % order.length];

    try {
      const origin = getThemeOrigin(event, button);
      await animateThemeToggle(next, origin, reducedMotionQuery.matches);
    } finally {
      window.setTimeout(() => {
        button.removeAttribute('disabled');
        isAnimatingThemeToggle = false;
      }, toggleLockMs);
    }
  };

  const header = document.querySelector<HTMLElement>('[data-header]');
  const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
  const prefersReducedMotion = reducedMotionQuery.matches;

  const updateHeaderState = () => {
    if (!header) return;
    const isScrolled = window.scrollY > 6;
    header.classList.toggle('is-scrolled', isScrolled);
  };

  document.getElementById('theme-toggle')?.addEventListener('click', handleToggleClick);
  render(getPreference());

  window.addEventListener('themechange', (event: Event) => {
    const detail = (event as CustomEvent<{ theme?: 'light' | 'dark'; resolved?: 'light' | 'dark' }>)
      .detail;
    const theme: 'light' | 'dark' = detail?.theme ?? getPreference();
    const resolved: 'light' | 'dark' | undefined = detail?.resolved;
    render(theme, resolved);
  });

  updateHeaderState();
  const scrollHandler = () => updateHeaderState();
  window.addEventListener('scroll', scrollHandler, { passive: true });

  if (prefersReducedMotion) {
    header?.classList.add('reduce-motion');
  }
</script>
