---
import { getPostConfig } from '../config/loaders';

const postConfig = getPostConfig();
const lang = Astro.props.lang || postConfig.comments.giscus.lang;
const giscus = postConfig.comments.giscus;
---

<section id="comments" class="mt-12">
  <div class="border-t border-zinc-200 dark:border-zinc-700 pt-8">
    <script
      is:inline
      src="https://giscus.app/client.js"
      data-repo={giscus.repo}
      data-repo-id={giscus.repoId}
      data-category={giscus.category}
      data-category-id={giscus.categoryId}
      data-mapping={giscus.mapping}
      data-strict={giscus.strict}
      data-reactions-enabled={giscus.reactionsEnabled}
      data-emit-metadata={giscus.emitMetadata}
      data-input-position={giscus.inputPosition}
      data-theme={giscus.theme}
      data-lang={lang}
      crossorigin="anonymous"
      async></script>
  </div>
</section>

<script is:inline>
  (() => {
    if (typeof window === 'undefined' || typeof document === 'undefined') return;

    // Mapping uses `pathname` to keep one discussion per URL path, which is stable for static sites.
    const themeMap = {
      light: 'light',
      dark: 'dark_dimmed',
    };

    const getResolvedTheme = () =>
      document.documentElement.dataset.theme === 'dark' ||
      document.documentElement.classList.contains('dark')
        ? 'dark'
        : 'light';

    let activeTheme = getResolvedTheme();

    const setContainerTheme = (theme) => {
      const container = document.getElementById('comments');
      if (container) {
        container.setAttribute('data-giscus-theme', theme);
      }
    };

    const postThemeMessage = (resolvedTheme) => {
      const effective = resolvedTheme ?? activeTheme;
      const nextTheme = themeMap[effective] ?? 'light';
      setContainerTheme(nextTheme);
      const iframe = document.querySelector('iframe.giscus-frame');
      if (iframe) {
        iframe.contentWindow?.postMessage(
          { giscus: { setConfig: { theme: nextTheme } } },
          'https://giscus.app',
        );
      }
      window.dispatchEvent(
        new CustomEvent('giscus-theme-applied', {
          detail: { theme: nextTheme, resolved: effective },
        }),
      );
    };

    const syncTheme = (resolvedOverride) => {
      const detected = resolvedOverride ?? getResolvedTheme();
      if (detected !== activeTheme) {
        activeTheme = detected;
      }
      postThemeMessage(detected);
    };

    const observer = new MutationObserver(() => syncTheme());
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class', 'data-theme'],
    });

    window.addEventListener('themechange', (event) => {
      const detail = event?.detail || {};
      if (detail.resolved) {
        syncTheme(detail.resolved);
      } else {
        syncTheme();
      }
    });

    const waitForFrame = () => {
      const frame = document.querySelector('iframe.giscus-frame');
      if (!frame) {
        requestAnimationFrame(waitForFrame);
        return;
      }

      const sendWhenReady = () => postThemeMessage();
      if (frame instanceof HTMLIFrameElement) {
        if (frame.complete) {
          sendWhenReady();
        } else {
          frame.addEventListener('load', sendWhenReady, { once: true });
        }
      }
      // Ensure we apply the current theme even if the iframe was already ready.
      postThemeMessage();
    };

    // Run once after load to sync the initial theme and keep retrying until the iframe is present.
    waitForFrame();
    syncTheme();
  })();
</script>
