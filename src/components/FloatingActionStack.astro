---
import {
  BUTTON_CLASSNAMES,
  BUTTON_ICON_CLASSNAMES,
  STACK_CLASSNAMES,
  buildActions,
} from '../lib/ui/floatingActionStack';

export interface Props {
  enableTop?: boolean;
  enableToc?: boolean;
  enableBottom?: boolean;
  targetSelector?: string;
}

const {
  enableTop = true,
  enableToc = true,
  enableBottom = true,
  targetSelector = '[data-article]',
} = Astro.props;

const actions = buildActions({ enableTop, enableToc, enableBottom });
---

{
  actions.length > 0 && (
    <div
      class={`${STACK_CLASSNAMES}`}
      data-floating-action-stack
      data-target-selector={targetSelector}
      style={`inset-inline-end: calc(env(safe-area-inset-right, 0px) + 1rem); inset-block-end: calc(env(safe-area-inset-bottom, 0px) + 1rem);`}
    >
      {actions.map((action, index) => (
        <button
          type="button"
          class={BUTTON_CLASSNAMES}
          data-floating-action-button
          data-action={action.kind}
          data-visible={action.kind === 'top' ? 'false' : 'true'}
          style={`transition-delay: ${index * 10}ms;`}
          aria-label={action.ariaLabel}
          {...(action.dataAttributes || {})}
        >
          <span class="sr-only">{action.label}</span>
          <span aria-hidden="true" class={BUTTON_ICON_CLASSNAMES}>
            {action.icon}
          </span>
        </button>
      ))}
    </div>
  )
}

<script>
  const stack = document.querySelector('[data-floating-action-stack]') as HTMLElement | null;
  const targetSelector = stack?.dataset.targetSelector || '[data-article]';
  const topButton = stack?.querySelector('[data-action="top"]') as HTMLButtonElement | null;
  const bottomButton = stack?.querySelector('[data-action="bottom"]') as HTMLButtonElement | null;
  const tocButton = stack?.querySelector('[data-action="toc"]') as HTMLButtonElement | null;
  const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
  const prefersReduce = reducedMotionQuery.matches;
  const tocRoot = document.querySelector('[data-mobile-toc]') as HTMLElement | null;

  const article = targetSelector
    ? (document.querySelector(targetSelector) as HTMLElement | null)
    : null;

  let start = 0;
  let contentHeight = 0;
  let ticking = false;

  // Find the actual scrolling container
  const getScrollContainer = (): HTMLElement | Window => {
    if (!article) return window;

    let element = article.parentElement;
    while (element) {
      const style = window.getComputedStyle(element);
      const overflowY = style.overflowY;
      const isScrollable =
        (overflowY === 'auto' || overflowY === 'scroll') &&
        element.scrollHeight > element.clientHeight;

      if (isScrollable) {
        return element;
      }
      element = element.parentElement;
    }

    return window;
  };

  const scrollContainer = getScrollContainer();

  const measure = () => {
    if (!article) return;
    const rect = article.getBoundingClientRect();
    start = rect.top + window.scrollY;
    contentHeight = article.scrollHeight;
  };

  const clamp = (value: number, min: number, max: number): number =>
    Math.min(Math.max(value, min), max);

  const setButtonVisibility = (button: HTMLButtonElement | null, visible: boolean) => {
    if (!button) return;
    button.dataset.visible = visible ? 'true' : 'false';
  };

  const updateVisibility = () => {
    if (!article) return;
    const threshold = 120;
    const hasScrollableContent = contentHeight > window.innerHeight + 40;
    const showTop = window.scrollY > start + threshold;
    setButtonVisibility(topButton, showTop);
    setButtonVisibility(bottomButton, hasScrollableContent);
    ticking = false;
  };

  const requestTick = () => {
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(updateVisibility);
    }
  };

  const scrollToTop = () => {
    const target = clamp(start, 0, Number.MAX_SAFE_INTEGER);
    window.scrollTo({ top: target, behavior: prefersReduce ? 'auto' : 'smooth' });
  };

  const scrollToBottom = () => {
    // Try to find the bottom anchor first
    const bottomAnchor = document.getElementById('page-bottom-anchor');

    if (bottomAnchor) {
      // Use scrollIntoView with the anchor for precise positioning
      bottomAnchor.scrollIntoView({
        block: 'end',
        behavior: prefersReduce ? 'auto' : 'smooth',
      });

      // Add a secondary calibration after a delay to handle async content
      // This ensures we scroll to the true bottom even if images/iframes load after initial scroll
      let retryCount = 0;
      const maxRetries = 2;

      const recalibrate = () => {
        if (retryCount >= maxRetries) return;
        retryCount++;

        setTimeout(() => {
          // Check if we're already at the bottom
          const scrollElement =
            scrollContainer instanceof Window ? document.documentElement : scrollContainer;
          const currentScroll =
            scrollContainer instanceof Window ? window.scrollY : scrollContainer.scrollTop;
          const maxScroll = scrollElement.scrollHeight - scrollElement.clientHeight;

          // If we're not within 10px of the bottom, scroll again
          if (maxScroll - currentScroll > 10) {
            bottomAnchor.scrollIntoView({
              block: 'end',
              behavior: prefersReduce ? 'auto' : 'smooth',
            });
            recalibrate();
          }
        }, 300);
      };

      recalibrate();
    } else {
      // Fallback: use document scroll height
      const scrollElement =
        scrollContainer instanceof Window ? document.documentElement : scrollContainer;
      const maxScroll = Math.max(scrollElement.scrollHeight - scrollElement.clientHeight, start);

      if (scrollContainer instanceof Window) {
        window.scrollTo({ top: maxScroll, behavior: prefersReduce ? 'auto' : 'smooth' });
      } else {
        scrollContainer.scrollTo({ top: maxScroll, behavior: prefersReduce ? 'auto' : 'smooth' });
      }
    }
  };

  const syncTocState = (open: boolean) => {
    if (!stack) return;
    stack.dataset.tocOpen = open ? 'true' : 'false';
  };

  syncTocState(tocRoot?.dataset.open === 'true');

  if (stack && article) {
    measure();
    updateVisibility();

    window.addEventListener('scroll', requestTick, { passive: true });
    window.addEventListener('resize', () => {
      measure();
      requestTick();
    });

    window.addEventListener(
      'load',
      () => {
        measure();
        updateVisibility();
      },
      { once: true },
    );

    topButton?.addEventListener('click', scrollToTop);
    bottomButton?.addEventListener('click', scrollToBottom);
  }

  tocButton?.addEventListener('click', () => {
    requestAnimationFrame(() => tocButton?.blur());
  });

  window.addEventListener('mobile-toc:toggle', (event: Event) => {
    const detail = (event as CustomEvent<{ open: boolean }>).detail;
    if (!detail) return;
    syncTocState(detail.open);
  });

  if (tocRoot) {
    const observer = new MutationObserver(() => {
      syncTocState(tocRoot.dataset.open === 'true');
    });
    observer.observe(tocRoot, { attributes: true, attributeFilter: ['data-open'] });
  }
</script>
